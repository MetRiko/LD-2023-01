[gd_scene load_steps=5 format=2]

[ext_resource path="res://icon.png" type="Texture" id=1]

[sub_resource type="CircleShape2D" id=1]
radius = 14.0

[sub_resource type="Shader" id=2]
code = "shader_type canvas_item;

void vertex() {
	UV -= vec2(0.5);
}

float dis_slime_shape(vec2 p, vec2 s, float rad) {
	vec2 v = p - s;
	float ang = atan(v.y, v.x);
	if (v.y <= 0.0) {
		return length(v);
	}
	else {
		return length(v) / abs(v.y);
//		if (abs(v.x) < rad) return abs(v.y);
//		else return distance(p, s + vec2(rad, 0.0) * sign(v.x));
//		else return 100.0;
	}
//	float ang = atan()
}

void fragment() {
	float PI = 3.14159;
	float TAU = 3.14159 * 2.0;
	float start_angles[] = {0.0, TAU * 0.3333, TAU * 0.6666, TAU * 1.0};
//	float start_dists[] = {0.25, 0.15, 0.2, 0.175};
	float start_dists[] = {0.2, 0.2, 0.2, 0.2};
	float start_radiuses[] = {0.05, 0.05, 0.05, 0.05};

	COLOR = vec4(0.0, 0.0, 0.0, 0.0);
	
	float fd = 0.0;
	int n = 30;
	
	for (int ix = 0; ix < n; ++ix) {
		int i = ix % 4;
		float ang = start_angles[i];
		float dis = start_dists[i];
		float rad = start_radiuses[i];
		rad *= 0.1;
		int s = (ix % 2) * 2 - 1;
//		ang += float(s) * TIME * 0.8 + float(s) * ((sin(TIME * 0.5) + 1.0) * 0.1) * 8.0 + (sin(float(ix+1))) * 0.3;
		
		ang = (float(ix) / float(n-1)) * TAU;
		ang += (sin(TIME * 0.8 * float(ix) * 0.1) + 1.0) * 0.5 * float(s);
		
		float a = mod(ang, PI); // 0 - TAU
		float up_force = sin(ang) * 0.1;
		
		up_force = max(up_force, 0.0);
		
//		if (up_force < 0.0) {
//			up_force *= -5.0;
//		}
//		if 
		
//		ang = 0.6;
		if (ix > 0) {
//			dis *= 0.75;
//			dis = (dis + (sin(TIME * float(i) * 0.1) + 1.0) * 0.5 * 0.05) * 0.75;
			
			dis = 0.1 + 0.01;
			
//			dis = (dis + sin(TIME * float(ix + 1) * 0.1) * 0.05) * 0.75;
		}
		else {
			ang = PI + 0.1;
			rad = 0.1;
			dis = 0.0;
			up_force = 0.0;
		}
		
		vec2 offset = vec2(cos(ang), sin(ang)) * dis;
		offset.y -= up_force;
		
		float thickness = 0.1;
//		float thickness = 0.4;
//		if (ix == 0) thickness = 1.0;
		float thickness_rad = thickness + rad;
		
//		float d = distance(UV, offset) * (abs(sin(ang * 0.5)) * 0.1 + 0.9);
		float d = distance(UV, offset);

		
		if (mod(ang, TAU) < PI) {
			d *= (sin(ang)) * 0.5 + 1.0;
		}
//		float nd2 = max(min(d, thickness_rad) - rad, 0.0) / thickness;

		if (ix == 0) {
			d = dis_slime_shape(UV, offset, 0.4);
//			nd2 = d;
		}
//		if (ix % 2 == 1) {
//			nd2 = nd2 - 1.0;
//		}
		
//		float nd = min(max(d - rad, 0.0), thickness) / thickness;
//		nd = 1.0 - nd;
		
//		if (nd2 <= 1.0) {
//			fd += nd2;
//			++count;
//		}

//		fd = min(fd, d);
//		float nd = 1.0 / nd2;
		float nd = 1.0 / d;
//		fd = min(fd, nd);
		
		fd += nd;
//		if (ix % 2 == 1) {
//			fd -= 1.2 * nd;
//
//		}

//		d = (rad - min(rad, d)) / rad;
//		fd = max(fd, nd2);
//		if (d < rad) {
//			COLOR = vec4(0.0, 0.0, 0.0, 1.0);
//		}
	}
	
//	fd = fd / rad_sum;
	fd = fd / float(n);
	
	if (fd > 9.0) {
		COLOR = vec4(0.0, 1.0, 0.0, 1.0);
	}
//	COLOR = vec4(0.0, fd * fd * 0.01,  0.0, max(min(fd * 0.02, 1.0), 0.0));
//	COLOR = vec4(0.0, fd * fd * 0.01,  0.0, 1.0);
//	else if (fd < -4.0) {
//		COLOR = vec4(1.0, 0.0, 0.0, 1.0);
//	}
//	COLOR = vec4(0.0, fd , 0.0, 1.0);
//	if (fd < 2.0) {
//		COLOR = vec4(0.0, 1.0, 0.0, 1.0);
//	}
//	fd /= float(count);
	
//	if (fd < 0.2) {
//		COLOR = vec4(0.0, 1.0, 0.0, 1.0);
//	}

//	float dis = length(UV);
//
//	if (dis < 0.3) {
//		COLOR = vec4(0.0, 0.0, 0.0, 1.0);
//	}
	
//	float dis = sqrt(UV.x * UV.x + UV.y * UV.y);
//
//	float angle = atan(UV.y, UV.x) * 10.0 * sin(TIME) ;
//
//	float range = 0.3 + sin(TIME + angle) * 0.01;
	
//	else {
//		COLOR = vec4(0.0, 0.0, 0.0, 0.0);
//	}
}"

[sub_resource type="ShaderMaterial" id=3]
shader = SubResource( 2 )

[node name="SlimeTesting" type="Node2D"]

[node name="Slime" type="KinematicBody2D" parent="."]
position = Vector2( 73, 63 )

[node name="CollisionShape2D" type="CollisionShape2D" parent="Slime"]
shape = SubResource( 1 )

[node name="Icon" type="Sprite" parent="Slime"]
material = SubResource( 3 )
position = Vector2( 0, 4 )
scale = Vector2( 1.28125, 1.28125 )
texture = ExtResource( 1 )
