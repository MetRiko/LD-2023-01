[gd_scene load_steps=5 format=2]

[ext_resource path="res://icon.png" type="Texture" id=1]

[sub_resource type="Shader" id=2]
code = "shader_type canvas_item;

void vertex() {
	UV -= vec2(0.5);
}

float dis_slime_shape(vec2 p, vec2 s, float rad) {
	vec2 v = p - s;
	float ang = atan(v.y, v.x);
	if (v.y <= 0.0) {
//		return max(length(v) - rad, 0.0);
		return length(v);
	}
	else {
		return length(v) / abs(v.y);
//		if (abs(v.x) < rad) return abs(v.y);
//		else return distance(p, s + vec2(rad, 0.0) * sign(v.x));
//		else return 100.0;
	}
//	float ang = atan()
}

float dis_orb_shape(vec2 p, vec2 s, float rad) {
	vec2 v = p - s;
	float d = length(v);
	d = max(d - rad, 0.0);
//	if (d > rad) d *= 2.0;
	return d;
}

void fragment() {
	float PI = 3.14159;
	float TAU = 3.14159 * 2.0;
//	float start_angles[] = {0.0, TAU * 0.3333, TAU * 0.6666, TAU * 1.0};
//	float start_dists[] = {0.25, 0.15, 0.2, 0.175};
//	float start_dists[] = {0.2, 0.2, 0.2, 0.2};
	float start_radiuses[] = {0.05, 0.05, 0.05, 0.05};

	COLOR = vec4(0.0, 0.0, 0.0, 0.0);
	
	float fd = 0.0;
	int n = 30;
	
	float u_rad = 0.4;
	float u_small_rad = 0.05;
	vec2 u_vel = normalize(vec2(1.0, 1.0));
	float u_speed = 1.0;
	
	u_speed = 0.0;
	float ta = TIME * 1.5;
	u_vel = normalize(vec2(cos(ta), sin(ta)));
	u_speed = (sin(TIME * 0.75) + 1.0) * 0.5;
//	u_speed = 1.0;
//	u_speed = 0.0;
	
	for (int ix = 0; ix < n; ++ix) {
		int i = ix % 4;
//		float ang = start_angles[i];
//		float dis = start_dists[i];
		float dis = u_rad;
//		float rad = start_radiuses[i];
		float rad = (float(i) + 1.0) * 0.05 * u_small_rad;
		int s = (ix % 2) * 2 - 1;
//		ang += float(s) * TIME * 0.8 + float(s) * ((sin(TIME * 0.5) + 1.0) * 0.1) * 8.0 + (sin(float(ix+1))) * 0.3;
		
		float ang = (float(ix) / float(n-1)) * TAU;
		ang += (sin(TIME * 0.8 * float(ix) * 0.1) + 1.0) * 0.5 * float(s);
		
		float a = mod(ang, PI); // 0 - TAU
		float up_force = sin(ang) * 0.1;
		
		up_force = max(up_force, 0.0);
		
//		if (up_force < 0.0) {
//			up_force *= -5.0;
//		}
//		if 
		
//		ang = 0.6;
		if (ix > 0) {
//			dis *= 0.75;
//			dis = (dis + (sin(TIME * float(i) * 0.1) + 1.0) * 0.5 * 0.05) * 0.75;
			
//			dis = 0.1 + 0.01;
			dis = u_rad * 0.5;
			if (ix < n / 2) {
				dis = u_rad * 0.45;
			}
			
//			dis = (dis + sin(TIME * float(ix + 1) * 0.1) * 0.05) * 0.75;
		}
		else {
			ang = PI + 0.1;
			rad = u_rad;
			dis = 0.0;
			up_force = 0.0;
		}
		
		vec2 offset = vec2(cos(ang), sin(ang)) * dis;
		offset.y -= up_force;
		
		vec2 vel_offset = (u_vel * 0.25 - offset);// * 0.2 * u_speed;
		float dd = length(vel_offset);
//		offset += vel_offset * (1.0 / dd) * 0.2;
//		offset += -offset * (u_small_rad * (1.0 - u_speed));

		offset += u_vel * u_speed * 0.2;
		offset -= offset * u_speed * (sin(TIME * 10.0 + float(ix) * 2.0) + 1.0) * 0.5;
//		offset += vel_offset * u_speed * (sin(TIME * 10.0 + float(ix) * 2.0) + 1.0) * 0.6;
//		offset += vel_offset * 0.6 * u_speed;
		
//		offset += vel_offset * u_speed;
//		offset = u_vel * 0.2 * u_speed;
		
		float thickness = 0.1;
//		float thickness = 0.4;
//		if (ix == 0) thickness = 1.0;
		float thickness_rad = thickness + rad;
		
//		float d = distance(UV, offset) * (abs(sin(ang * 0.5)) * 0.1 + 0.9);
		float d = distance(UV, offset);

		
//		d /= rad / 20.0;
//		float nd2 = max(min(d, thickness_rad) - rad, 0.0) / thickness;

		if (ix == 0) {
//			float speed_rad = u_rad * (1.0 - u_speed);
			d = dis_slime_shape(UV, offset, u_rad);
//			nd2 = d;
		}
		else {
			float speed_factor = (1.0 - u_speed) * 0.2 + 0.8;
			d = dis_orb_shape(UV, offset, u_small_rad * speed_factor);
			if (mod(ang, TAU) < PI) {
				d *= (sin(ang)) * 0.5 + 1.0;
			}
		}
//		if (ix % 2 == 1) {
//			nd2 = nd2 - 1.0;
//		}
		
//		float nd = min(max(d - rad, 0.0), thickness) / thickness;
//		nd = 1.0 - nd;
		
//		if (nd2 <= 1.0) {
//			fd += nd2;
//			++count;
//		}

//		fd = min(fd, d);
//		float nd = 1.0 / nd2;
		float nd = 1.0 / d;
		
//		if (ix == 0) {
//			nd *= 20.0;
//		}
		
//		fd = min(fd, nd);
		
		fd += nd;
//		fd = min(6.0 * float(n), fd);
//		fd = min(fd, nd);
//		if (ix % 2 == 1) {
//			fd -= 1.2 * nd;
//
//		}

//		d = (rad - min(rad, d)) / rad;
//		fd = max(fd, nd2);
//		if (d < rad) {
//			COLOR = vec4(0.0, 0.0, 0.0, 1.0);
//		}
	}
	
//	fd = fd / rad_sum;
	fd = fd / float(n);
	
	float x = fd * fd * 0.01;
	if (x > 0.6) {
		COLOR = vec4(0.0, 1.0, 0.0, 1.0);
	}
//	COLOR = vec4(0.0, fd * fd * 0.01,  0.0, max(min(fd * 0.02, 1.0), 0.0));
//	COLOR = vec4(0.0, fd * fd * 0.01,  0.0, 1.0);
//	else if (fd < -4.0) {
//		COLOR = vec4(1.0, 0.0, 0.0, 1.0);
//	}
//	COLOR = vec4(0.0, fd , 0.0, 1.0);
//	if (fd < 2.0) {
//		COLOR = vec4(0.0, 1.0, 0.0, 1.0);
//	}
//	fd /= float(count);
	
//	if (fd < 0.2) {
//		COLOR = vec4(0.0, 1.0, 0.0, 1.0);
//	}

//	float dis = length(UV);
//
//	if (dis < 0.3) {
//		COLOR = vec4(0.0, 0.0, 0.0, 1.0);
//	}
	
//	float dis = sqrt(UV.x * UV.x + UV.y * UV.y);
//
//	float angle = atan(UV.y, UV.x) * 10.0 * sin(TIME) ;
//
//	float range = 0.3 + sin(TIME + angle) * 0.01;
	
//	else {
//		COLOR = vec4(0.0, 0.0, 0.0, 0.0);
//	}
}"

[sub_resource type="ShaderMaterial" id=3]
shader = SubResource( 2 )

[sub_resource type="CircleShape2D" id=1]
radius = 14.0

[node name="SlimeTesting" type="Node2D"]

[node name="Slime" type="KinematicBody2D" parent="."]
position = Vector2( 73, 63 )

[node name="Icon" type="Sprite" parent="Slime"]
material = SubResource( 3 )
position = Vector2( 0, 4 )
scale = Vector2( 1.28125, 1.28125 )
texture = ExtResource( 1 )

[node name="CollisionShape2D" type="CollisionShape2D" parent="Slime"]
visible = false
shape = SubResource( 1 )
